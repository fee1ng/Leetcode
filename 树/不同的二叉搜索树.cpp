class Solution {
public:
    //动态规划
    /*
    G(n)长度为 n 的序列能构成的不同二叉搜索树的个数
    F(i,n):以 i 为根、序列长度为n的不同二叉搜索树个数 (1<=i<=n)
    根据二叉搜索树建立的思路，即选取1-n中的每一个数各自当根节点，递归左半区间与右半区间建议二叉搜索树
    故G(n)=F(1,n)+F(2,n)+...+F(n,n)	(1)
    以[1,2,3,4,5,6,7]为例，以3为根节点创建二叉搜索树，从左半区间[1,2]构建左子树G(2)，右半区间[4,5,6,7]构造右子树G(4)，      i=3,n=7
    故F(3,7)=G(2)*G(4)，即G(i-1)+G(n-i)	(2)
    联立(1)(2)，有
    G(n)=求和   [G(i-1)*G(n-i)],	1<=i<=n
    且G(0)=1,G(1)=1
    故要求G(7)，则G(7)=G(0)*G(6)+G(1)*G(5)+G(2)*G(4)+G(3)*G(3)
    所以要先求G(2)-G(6)，即分别令i=n=2,3,4,5,6,7,求G(2)-G(6)，最后求G(7)   第一层循环i
    要求G(2),则G(2)=G(0)*G(2)+G(1)*G(0)，需要第二层循环j=1;j<=i;j++，表示
    公式G(n)=求和   [G(i-1)*G(n-i)],	1<=i<=n  中的i,即这里的j等于公式中的i
    */
    int numTrees(int n) {
        vector<int> G(n + 1);
        G[0] = 1, G[1] = 1;
        for (int i = 2;i <= n;i++)      //求G(2)-G(6)
            for (int j = 1;j <= i;j++)  //求G(2)-G(6)中每一个G[i]的具体过程
                G[i] += G[j - 1] * G[i - j];
        return G[n];
    }
};